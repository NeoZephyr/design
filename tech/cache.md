## 数据不一致
先更新数据库，再更新缓存：
1. A 请求将数据库中 ID 为 1 的用户年龄从 19 变更为 20
2. B 请求更新 ID 为 1 的用户数据，把数据库中的年龄变更为 21，然后变更缓存中的年龄为 21
3. A 请求更新缓存数据，把缓存中的年龄变更为 20

先删除缓存，后更新数据库：
1. 请求 A 要更新用户年龄为 21，先删除缓存中的内容
2. 请求 B 读取用户的年龄，查询缓存未命中，从数据库中读取到年龄为 20，并且写入到缓存中
3. 请求 A 继续更改数据库，将用户的年龄更新为 21

先更新数据库，后删除缓存：
1. 用户数据在缓存中不存在，请求 A 读取从数据库中查询到年龄为 20
2. 请求 B 更新数据库中的年龄为 21，并且清空缓存
3. 请求 A 把从数据库中读到的年龄为 20 的数据写入到缓存中

这种问题出现的几率并不高，原因是缓存的写入通常远远快于数据库的写入，所以在实际中很难出现请求 B 已经更新了数据库并且清空了缓存，请求 A 才更新完缓存的情况


## Cache Aside
### 读策略
1. 从缓存中读取数据
2. 如果缓存命中，则直接返回数据
3. 如果缓存不命中，则从数据库中查询数据
4. 查询到数据后，将数据写入到缓存中，并且返回给用户

### 写策略
1. 更新数据库中的记录
2. 删除缓存记录

Cache Aside 策略是开发中最经常使用的缓存策略，不过在使用时也要依情况而变。比如说当新注册一个用户，按照这个更新策略，你要写数据库，然后清理缓存。可当注册用户后立即读取用户信息，并且数据库主从分离时，会出现因为主从延迟所以读不到用户信息的情况

解决这个问题的办法就是在插入新数据到数据库之后写入缓存，这样后续的读请求就会从缓存中读到数据了。并且因为是新注册的用户，所以不会出现并发更新用户信息的情况

Cache Aside 最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：

1. 在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题

2. 在更新数据时更新缓存，给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受


## Read/Write Through（读穿/写穿）策略
### Write Through
先查询要写入的数据在缓存中是否已经存在。如果存在，则更新缓存中的数据，并且由缓存组件同步更新到数据库中；如果不存在，我们把这种情况叫做 Write Miss（写失效）

一般来说，可以选择两种 Write Miss 方式：一个是 Write Allocate（按写分配），写入缓存相应位置，再由缓存组件同步更新到数据库中；另一个是 No-write allocate（不按写分配），做法是不写入缓存中，而是直接更新到数据库中

一般选择 No-write allocate 方式，原因是无论采用哪种方式，都需要同步将数据更新到数据库中，而 No-write allocate 方式相比 Write Allocate 还减少了一次缓存的写入，能够提升写入的性能

### Read Through
先查询缓存中数据是否存在，如果存在则直接返回，如果不存在，则由缓存组件负责从数据库中同步加载数据


## Write Back（写回）策略
### 写策略
在写入数据时只写入缓存，并且把缓存块儿标记为脏数据的。脏数据只有被再次使用时才会将其中的数据写入到后端存储中

在 Write Miss 的情况下，采用的 Write Allocate 的方式，也就是在写入后端存储的同时要写入缓存，这样在之后的写请求中都只需要更新缓存即可，而无需更新后端存储了

### 读策略
读取缓存时如果发现缓存命中则直接返回缓存数据。如果缓存不命中则寻找一个可用的缓存块儿，如果这个缓存块儿是脏的，就把缓存块儿中之前的数据写入到后端存储中，并且从后端存储加载数据到缓存块儿。如果不是脏的，则由缓存组件将后端存储中的数据加载到缓存中，最后将缓存设置为不是脏的，返回数据

这种策略是计算机体系结构中的设计，比如在向磁盘中写数据时采用的就是这种策略。无论是操作系统层面的 Page Cache，还是日志的异步刷盘，亦或是消息队列中消息的异步写入磁盘，大多采用了这种策略。因为这个策略在性能上的优势毋庸置疑，它避免了直接写磁盘造成的随机写问题

