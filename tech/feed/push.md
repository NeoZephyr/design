## 信息流关注点
1. 关注延迟数据
2. 考虑如何支撑高并发的访问
3. 信息流拉取性能与数据聚合


用户 A 有三个粉丝 B、C、D
```sql
insert into outbox(userId, feedId, create_time) values("A", feedId, currentTime);
insert into inbox(userId, feedId, create_time) values("B", feedId, currentTime);
insert into inbox(userId, feedId, create_time) values("C", feedId, currentTime);
insert into inbox(userId, feedId, create_time) values("D", feedId, currentTime);
```

查询 B 的信息流
```sql
select feedId from inbox where userId = "B";
```


## 推模式问题
首先，就是消息延迟。明星的粉丝数庞大，如果在发微博的同时还要将微博写入到上千万人的收件箱中，那么发微博的响应时间会非常慢。即使使用消息队列来消除写入的峰值，由于写入收件箱的消息实在太多，还是有可能在几个小时之后才能够看到明星发布的内容，非常影响用户体验

其次，存储成本很高

先设计一张 Feed 表，这个表主要存储微博的基本信息，包括微博 ID、创建人的 ID、创建时间、微博内容、微博状态等，使用微博 ID 做哈希分库分表
另外一张表是用户的发件箱和收件箱表，也叫做 TimeLine 表，主要有三个字段，用户 ID、微博 ID 和创建时间，使用用户的 ID 做哈希分库分表

由于推模式需要给每一个用户都维护一份收件箱的数据，所以数据的存储量极大

最后，在处理取消关注和删除微博的逻辑时会更加复杂。比如明星删除了一条微博，如果要删除她所有粉丝收件箱中的这条微博，会带来额外的分发压力


## 推模式解决方案
解决消息延迟：
一方面，在消息处理上，可以启动多个线程并行地处理微博写入的消息
另一方面，由于消息流在展示时可以使用缓存来提升读取性能，必要时可以采用写入性能更好的数据库存储引擎

解决存储成本高：
选择压缩率更高的存储引擎，定期地清理数据（微博的数据有比较明显的实效性），只保留最近 1 个月的数据

解决取消关注：
在读取自己信息流的时候，判断每一条微博是否被删除以及是否还关注这条微博的作者，如果没有的话，就不展示这条微博的内容了。尽量减少对数据库多余的写操作。


## 推模式适用场景
推模式究竟适合于一个用户的粉丝数比较有限的场景，比如说微信朋友圈，有限的粉丝数可以保证消息能够尽量快地被推送给所有的粉丝，增加的存储成本也比较有限。如果业务中粉丝数是有限制的，那么在实现以关注关系为基础的信息流时，也可以采用推模式来实现
