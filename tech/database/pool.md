## 数据库连接池
相比于 SQL 的执行，MySQL 建立连接的过程是比较耗时的。这在请求量小的时候影响不大，因为无论是建立连接还是执行 SQL，耗时都是毫秒级别的。可是请求量上来之后，如果仍然建立一次连接只执行一条 SQL，那么单位时间内，大部分时间都用来建立连接了


数据库连接池的重要配置：最小连接数和最大连接数，它们控制着从连接池中获取连接的流程：
1. 如果当前连接数小于最小连接数，则创建新的连接处理数据库请求
2. 如果连接池中有空闲连接则复用空闲连接
3. 如果空闲池中没有连接并且当前连接数小于最大连接数，则创建新的连接处理请求
4. 如果当前连接数已经大于等于最大连接数，则按照配置中设定的时间等待旧的连接可用
5. 如果等待超过了这个设定时间则向用户抛出错误

一般在线上我建议最小连接数控制在 10 左右，最大连接数控制在 20～30 左右即可

在使用连接池的时候，需要特别注意的一点就是：连接的维护。一般连接问题出现，有以下几种原因：
1. 数据库的域名对应的 IP 发生了变更，连接池的连接还是使用旧的 IP，当旧的 IP 下的数据库服务关闭后，再使用这个连接查询就会发生错误
2. MySQL 的参数 wait_timeout 控制着数据库连接闲置的时间。当超过这个时间后，数据库会主动的关闭这条连接。这个机制对于数据库使用方是无感知的，当使用这个被关闭的连接时就会发生错误

有以下几种方式保证连接的可用性：
1. 启动一个线程来定期检测连接池中的连接是否可用，比如使用连接发送 select 1 的命令给数据库看是否会抛出异常，如果抛出异常则将这个连接从连接池中移除，并且尝试关闭。推荐使用这种方式

2. 在获取到连接之后，先校验连接是否可用，如果可用才会执行 SQL 语句。比如 DBCP 连接池的 testOnBorrow 配置项。这种方式在获取连接时会引入多余的开销，尽量不要开启


## 线程池
ThreadPoolExecutor 是一种线程池的实现，它有两个重要的参数：coreThreadCount 和 maxThreadCount，这两个参数控制着线程池的执行过程：
1. 如果线程池中的线程数少于 coreThreadCount 时，处理新的任务时会创建新的线程
2. 如果线程数大于 coreThreadCount 则把任务丢到一个队列里面，由当前空闲的线程执行
3. 当队列中的任务堆积满了的时候，则继续创建线程，直到达到 maxThreadCount
4. 当线程数达到 maxTheadCount 时还有新的任务提交，那么我们就不得不将它们丢弃了

线程池有以下需要注意的点：
1. 线程池优先把任务放入队列暂存起来，而不是创建更多的线程，这比较适用于执行 CPU 密集型的任务。因为执行 CPU 密集型的任务时 CPU 比较繁忙，因此只需要创建和 CPU 核数相当的线程就好了，多了反而会造成线程上下文切换，降低任务执行效率。所以当当前线程数超过核心线程数时，线程池不会增加线程，而是放在队列里等待核心线程空闲下来

2. Web 系统通常都有大量的 IO 操作，比如查询数据库、查询缓存等等。任务在执行 IO 操作的时候 CPU 就空闲了下来，这时如果增加执行任务的线程数而不是把任务暂存在队列中，就可以在单位时间内执行更多的任务，大大提高了任务执行的吞吐量。所以 Tomcat 使用的线程池就做了一些改造，当线程数超过 coreThreadCount 之后会优先创建线程，直到线程数到达 maxThreadCount

3. 线程池中使用的队列的堆积量需要重点监控，对于实时性要求比较高的任务来说，这个指标尤为关键

4. 不要使用无界队列。大量的任务堆积会占用大量的内存空间，一旦内存空间被占满就会频繁地触发 Full GC，造成服务不可用


## 池化缺陷
1. 存储池中的对象需要消耗多余的内存，如果对象没有被频繁使用，就会造成内存上的浪费
2. 存储池中的对象需要在系统启动的时候就预先创建完成，这在一定程度上增加了系统启动时间
