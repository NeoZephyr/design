## 性能瓶颈
### 商品详情页面
提前将整个抢购商品页面生成为一个静态页面，push 到 CDN 节点，并且在浏览器端缓存该页面的静态资源文件

### 抢购倒计时
抢购倒计时是服务端时间，初始化时间需要从服务端获取，并且在用户点击购买时，还需要服务端判断抢购时间是否已经到了。

如果商品详情每次刷新都去后端请求最新的时间，将会把整个后端服务拖垮。可以改成初始化时间从客户端获取，每隔一段时间主动去服务端刷新同步一次倒计时，这个时间段是随机时间，避免集中请求服务端。这种方式可以避免用户主动刷新服务端的同步时间接口

### 获取购买资格
进入订单详情页面后，需要填写相关的订单信息，例如收货地址、联系方式等，在这样一个过程中，很多用户可能还会犹豫，甚至放弃购买。如果把这个环节设定为一定能购买成功，那我们就只能让同等库存的用户进来，一旦用户放弃购买，这些商品可能无法再次被其他用户抢购，会大大降低商品的抢购销量

增加购买资格的环节，选择让超过库存的用户量进来提交订单页面，可以保证有足够提交订单的用户量，确保抢购活动中商品的销量最大化

获取购买资格这步的并发量会非常大，还是基于分布式的，通常我们可以通过 Redis 分布式锁来控制购买资格的发放

### 提交订单
由于抢购入口的请求量会非常大，可能会占用大量带宽，为了不影响提交订单的请求，建议将提交订单的子域名与抢购子域名区分开，分别绑定不同网络的服务器

用户点击提交订单，需要先校验库存，库存足够时，用户先扣除缓存中的库存，再生成订单。如果校验库存和扣除库存都是基于数据库实现的，那么每次都去操作数据库，瞬时的并发量就会非常大，对数据库来说会存在一定的压力，从而会产生性能瓶颈。与获取购买资格一样，可以通过分布式锁来优化扣除消耗库存的设计

由于已经缓存了库存，所以在提交订单时，库存的查询和冻结并不会给数据库带来性能瓶颈。在这之后，还有一个订单的幂等校验，为了提高系统性能，同样可以使用分布式锁来优化

而保存订单信息一般都是基于数据库表来实现的，在单表单库的情况下，碰到大量请求，特别是在瞬时高并发的情况下，磁盘 I/O、数据库请求连接数以及带宽等资源都可能会出现性能瓶颈。此时可以考虑对订单表进行分库分表，通常可以基于 userid 字段来进行 hash 取模，实现分库分表，从而提高系统的并发能力

### 支付回调业务操作
在用户支付订单完成之后，一般会有第三方支付平台回调我们的接口，更新订单状态

除此之外，还可能存在扣减数据库库存的需求。如果库存是基于缓存来实现查询和扣减，那提交订单时的扣除库存就只是扣除缓存中的库存，为了减少数据库的并发量，在用户付款之后，在支付回调的时候去选择扣除数据库中的库存

此外，还有订单购买成功的短信通知服务，一些商城还提供了累计积分的服务

在支付回调之后，可以通过异步提交的方式，实现订单更新之外的其它业务处理，例如库存扣减、积分累计以及短信通知等


## 调优
### 限流实现优化
Nginx 中包含了两个限流模块：ngx_http_limit_conn_module 和 ngx_http_limit_req_module，前者是用于限制单个 IP 单位时间内的请求数量，后者是用来限制单位时间内所有 IP 的请求数量

```
limit_conn_zone $binary_remote_addr zone=addr:10m;
 
server {
    location / {
        limit_conn addr 1;
    }
}
```

```
http {
    limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
        location / {
            limit_req zone=one burst=5 nodelay;
        }
    }
}
```

### 流量削峰
瞬间有大量请求进入到系统后台服务之后，首先是要通过 Redis 分布式锁获取购买资格，这个时候看到了大量的 JedisConnectionException Could not get connection from pool 异常

由于 Redis 集群是基于哨兵模式部署的，哨兵模式部署的 Redis 也是一种主从模式，在写 Redis 的时候都是基于主库来实现的，在高并发操作一个 Redis 实例就很容易出现性能瓶颈

你可能会想到使用集群分片的方式来实现，但对于分布式锁来说，集群分片的实现只会增加性能消耗，这是因为我们需要基于 Redission 的红锁算法实现，需要对集群的每个实例进行加锁

后来我们使用 Redission 插件替换 Jedis 插件，由于 Jedis 的读写 I/O 操作还是阻塞式的，方法调用都是基于同步实现，而 Redission 底层是基于 Netty 框架实现的，读写 I/O 是非阻塞 I/O 操作，且方法调用是基于异步实现

但在瞬时并发非常大的情况下，依然会出现类似问题，此时，我们可以考虑在分布式锁前面新增一个等待队列，减缓抢购出现的集中式请求，相当于一个流量削峰。当请求的 key 值放入到队列中，请求线程进入阻塞状态，当线程从队列中获取到请求线程的 key 值时，就会唤醒请求线程获取购买资格

### 数据丢失问题
无论是服务宕机，还是异步发送给 MQ，都存在请求数据丢失的可能

重试机制是还原丢失消息的一种解决方案。在以上的回调案例中，可以在写入订单时，同时在数据库写入一条异步消息状态，之后再返回第三方支付操作成功结果。在异步业务处理请求成功之后，更新该数据库表中的异步消息状态

假设重启服务，那么系统就会在重启时去数据库中查询是否有未更新的异步消息，如果有，则重新生成 MQ 业务处理消息，供各个业务方消费处理丢失的请求数据

