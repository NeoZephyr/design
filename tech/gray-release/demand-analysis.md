调用方在替换某个接口的时候，先让小部分接口请求，调用新的接口，剩下的大部分接口请求，还是调用老的接口，验证没有问题之后，再逐步加大调用新接口的请求比例，最终，将所有的接口请求，都替换成调用新的接口


## 功能需求
组件使用者需要设置一个 key 值，来唯一标识要灰度的功能，然后根据自己业务数据的特点，选择一个灰度对象，在配置文件或者配置中心中，配置这个 key 对应的灰度规则和功能开关

灰度组件在业务系统启动的时候，会将这个灰度配置，按照事先定义的语法，解析并加载到内存对象中，业务系统直接使用组件提供的灰度判定接口，给业务系统使用，来判定某个灰度对象是否灰度执行新的代码逻辑


## 非功能性需求
### 易用性
灰度功能是代码级别的细粒度的灰度，而替代掉原来的 if-else 逻辑，是针对一个个业务来做的，跟业务强相关，要做到跟业务代码完全解耦，是不现实的。所以，在侵入性这一点上，灰度组件只能做妥协，容忍一定程度的侵入

灰度规则需要支持热更新，也就是说，在配置文件中，修改了灰度规则之后，系统在不重启的情况下会自动加载、更新灰度规则

### 扩展性
支持不同格式、不同存储方式的灰度规则配置方式。支持更加灵活的、复杂的灰度规则

### 性能
对于灰度组件来说，灰度的判断逻辑非常简单，而且不涉及访问外部存储，所以性能一般不会有太大问题。不过，仍然需要把灰度规则组织成快速查找的数据结构

### 容错性
在灰度组件出现异常时，既可以选择中止业务，也可以选择让业务继续执行。如果让业务继续执行，本不应该被灰度到的业务对象，就有可能被执行。这是否能接受，还是要看具体的业务

