## 客户端方案
客户端逻辑复杂且在多语言环境下不能复用

### 分片
写入数据时，需要把被写入缓存的数据分散到多个节点中，即进行数据分片。这样在某个节点故障的情况下，其他节点也可以提供服务，保证了一定的可用性。一般来讲，分片算法常见的就是 Hash 分片算法和一致性 Hash 分片算法两种

#### Hash 分片
Hash 分片的算法就是对缓存的 Key 做哈希计算，然后对总的缓存节点个数取余。这个算法最大的优点就是简单易理解，缺点是当增加或者减少缓存节点时，缓存总的节点个数变化造成计算出来的节点发生变化，从而造成缓存失效不可用。如果采用这种方法，最好建立在服务对于这组缓存命中率下降不敏感，比如下面还有另外一层缓存来兜底的情况下

#### 一致性 Hash
一致性 Hash 算法可以很好地解决增加和删减节点时，命中率下降的问题。这个算法将整个 Hash 值空间组织成一个虚拟的圆环，然后将缓存节点的 IP 地址或者主机名做 Hash 取值后，放置在这个圆环上。当需要确定某一个 Key 需要存取的节点的时候，先对这个 Key 做 Hash 取值，确定在环上的位置，然后按照顺时针方向行走，遇到的第一个节点就是要访问的节点

一致性 Hash 算法存在以下问题：
1. 缓存节点在圆环上分布不平均，会造成部分缓存节点的压力较大；当某个节点故障时，这个节点所要承担的所有访问都会被顺移到另一个节点上，会对后面这个节点造成压力

虚拟节点
将一个缓存节点计算多个 Hash 值分散到圆环的不同位置，这样既实现了数据的平均，而且当某一个节点故障或者退出的时候，它原先承担的 Key 将以更加平均的方式分配到其他节点上，从而避免雪崩的发生

2. 脏数据问题。一定要设置缓存的过期时间，当发生漂移时，之前存储的脏数据可能已经过期，就可以减少存在脏数据的几率


数据分片最大的优势就是缓解缓存节点的存储和访问压力，但在批量获取场景下，单个节点的访问量并没有减少，同时节点数太多会造成缓存访问的网站服务可用性得不到很好的保证，因为根据木桶原则，节点数过多也会增加出问题的概率，推荐 4 到 6 个节点为佳

### 主从机制
主从机制最大的优点就是当某一个 Slave 宕机时，还会有 Master 作为兜底，不会有大量请求穿透到数据库的情况发生，提升了缓存系统的高可用性

### 多副本
当客户端发起查询请求时，请求首先会先从多个副本组中选取一个副本组发起查询，如果查询失败，就继续查询 Master/Slave，并且将查询的结果回种到所有副本组中，避免副本组中脏数据的存在

基于成本的考虑，每一个副本组容量比 Master 和 Slave 要小，因此它只存储了更加热的数据


## 中间代理层方案
在性能上会有一些损耗

代理层是无状态的，主要负责读写请求的路由功能，并且在其中内置了一些高可用的逻辑，不同的开源中间代理层方案中使用的高可用策略各有不同。比如在 Twemproxy 中，Proxy 保证在某一个 Redis 节点挂掉之后会把它从集群中移除，后续的请求将由其他节点来完成；而 Codis 提供了一个叫 Codis Ha 的工具来实现自动从节点提主节点，在 3.2 版本之后换做了 Redis Sentinel 方式，从而实现 Redis 节点的高可用


## 服务端方案
依赖于组件的实现

Redis 在 2.4 版本中提出了 Redis Sentinel 模式来解决主从 Redis 部署时的高可用问题，它可以在主节点挂了以后自动将从节点提升为主节点，保证整体集群的可用性

Redis Sentinel 也是集群部署的，这样可以避免 Sentinel 节点挂掉造成无法自动故障恢复的问题。每一个 Sentinel 节点都是无状态的。在 Sentinel 中会配置 Master 的地址，Sentinel 会时刻监控 Master 的状态，当发现 Master 在配置的时间间隔内无响应，就认为 Master 已经挂了，然后从从节点中选取一个提升为主节点，并且把所有其他的从节点作为新主的从节点。Sentinel 集群内部在仲裁的时候，会根据配置的值来决定，当有几个 Sentinel 节点认为主挂掉可以做主从切换的操作

Redis Sentinel 不属于代理层模式，因为对于缓存的写入和读取请求不会经过 Sentinel 节点。Sentinel 节点在架构上和主从是平级的
