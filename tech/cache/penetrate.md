通过用户 ID 查询用户的信息，但是用户并未注册，缓存的读写策略采用 Cache Aside 策略


## 回种空值
当从数据库中查询到空值或者发生异常时，向缓存中回种一个空值。因为空值并不是准确的业务数据，并且会占用缓存的空间，所以给这个空值加一个比较短的过期时间，让空值在短时间之内能够快速过期淘汰

```java
Object nullValue = new Object();
try {
    Object valueFromDB = getFromDB(uid);
    if (valueFromDB == null) {
        cache.set(uid, nullValue, 10);
    } else {
        cache.set(uid, valueFromDB, 1000);
    }
} catch(Exception e) {
    cache.set(uid, nullValue, 10);
}
```

回种空值虽然能够阻挡大量穿透的请求，但如果有大量获取未注册用户信息的请求，缓存内就会有有大量的空值缓存，也就会浪费缓存的存储空间，如果缓存空间被占满了，还会剔除掉一些已经被缓存的用户信息反而会造成缓存命中率的下降

所以在使用的时候应该评估一下缓存容量是否能够支撑


## 布隆过滤器
判断一个元素是否在一个集合中。这种算法由一个二进制数组和一个 Hash 算法组成。基本思路如下：

把集合中的每一个值按照提供的 Hash 算法算出对应的 Hash 值，然后将 Hash 值对数组长度取模后得到需要计入数组的索引值，并且将数组这个位置的值从 0 改成 1。在判断一个元素是否存在于这个集合中时，只需要将这个元素按照相同的算法计算出索引值，如果这个位置的值为 1 就认为这个元素在集合中，否则则认为不在集合中


初始化一个长度为 20 亿的数组，选择一个 Hash 算法将目前现有的所有用户的 ID 计算出 Hash 值并且映射到这个大数组中，映射位置的值设置为 1，其它值设置为 0。新注册的用户除了需要写入到数据库中之外，也依照同样的算法更新布隆过滤器的数组中相应位置的值

当查询某一个用户的信息时，先查询这个 ID 在布隆过滤器中是否存在，如果不存在就直接返回空值，而不需要继续查询数据库和缓存，这样就可以极大地减少异常查询带来的缓存穿透

布隆过滤器主要有两个缺陷：
1. 在判断元素是否在集合中时是有一定错误几率的，比如它会把不是集合中的元素判断为处在集合中

主要是 Hash 算法存在着一定的碰撞几率。布隆过滤器的误判有一个特点，就是它只会出现 false positive 的情况。当布隆过滤器判断元素在集合中时，这个元素可能不在集合中。但是一旦布隆过滤器判断这个元素不在集合中时，它一定不在集合中

因此，布隆过滤器虽然存在误判的情况，但是还是会减少缓存穿透的情况发生，只是我们需要尽量减少误判的几率，这样布隆过滤器的判断正确的几率更高，对缓存的穿透也更少。一个解决方案是：

使用多个 Hash 算法为元素计算出多个 Hash 值，只有所有 Hash 值对应的数组中的值都为 1 时，才会认为这个元素在集合中，减少误判的几率

2. 不支持删除元素

假如两个元素 A 和 B 都是集合中的元素，它们有相同的 Hash 值，它们就会映射到数组的同一个位置。这时我们删除了 A，数组中对应位置的值也从 1 变成 0，那么在判断 B 的时候发现值是 0，也会判断 B 是不在集合中的元素，就会得到错误的结论

让数组中不再只有 0 和 1 两个值，而是存储一个计数。比如如果 A 和 B 同时命中了一个数组的索引，那么这个位置的值就是 2，如果 A 被删除了就把这个值从 2 改为 1。这个方案中的数组不再存储 bit 位，而是存储数值，也就会增加空间的消耗

所以，要依据业务场景来选择是否能够使用布隆过滤器，比如像是注册用户的场景下，因为用户删除的情况基本不存在，所以还是可以使用布隆过滤器来解决缓存穿透的问题的


## 极热点缓存
一旦失效会有大量请求穿透到数据库，对数据库造成瞬时极大的压力

解决思路是尽量地减少缓存穿透后的并发：
1. 在代码中，控制在某一个热点缓存项失效之后启动一个后台线程，穿透到数据库，将数据加载到缓存中，在缓存未加载之前，所有访问这个缓存的请求都不再穿透而直接返回

2. 通过在 Memcached 或者 Redis 中设置分布式锁，只有获取到锁的请求才能够穿透到数据库

比方说 ID 为 1 的用户是一个热点用户，当他的缓存失效后，先向 Memcached 中写入一个 key 为 lock.1 的缓存项，然后去数据库里面加载数据，当数据加载完成后再把这个 key 删掉。这时，如果另外一个线程也要请求这个用户的数据，它发现缓存中有 key 为 lock.1 的缓存，就认为目前已经有线程在加载数据库中的值到缓存中了，它就可以重新去缓存中查询数据，不再穿透数据库了

