## 限流规则
定义限流规则的语法格式，包括调用方、接口、限流阈值、时间粒度这几个元素

```yaml
configs:
- appId: app1
  limits:
  - api: /v1/user
    limit: 100
    unit: 60
  - api: /v1/order
    limit: 50
- appId: app2
  limits:
  - api: /v1/user
    limit: 50
```


## 限流算法
### 固定时间窗口
选定一个起始时间起点，之后每来一个接口请求，都给计数器（记录当前时间窗口内的访问次数）加一，如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次接口请求），累加访问次数超过限流值（比如 100 次），就触发限流熔断，拒绝接口请求。当进入下一个时间窗口之后，计数器清零重新计数

这种算法的限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。假设限流规则为每秒钟不超过 100 次接口请求。第一个 1 秒时间窗口内，100 次接口请求都集中在最后的 10 毫秒内，在第二个 1 秒时间窗口内，100 次接口请求都集中在最开始的 10 毫秒内。虽然两个时间窗口内流量都符合限流要求，但在两个时间窗口临界的 20 毫秒内集中有 200 次接口请求，集中在这 20 毫秒内的 200 次请求有可能会压垮系统

```java
private AtomicInteger counter;

ScheduledExecutorService timer = Executors.newSingleThreadScheduledExecutor();
time.scheduleAtFixedRate(new Runnable() {
    public void run() {
        counter.set(0);
    }
}, 0, 1, TimeUnit.SECONDS);
```
```java
public boolena isRateLimit() {
    return counter.incrementAndGet() >= allowedLimit;
}
```

### 滑动时间窗口
滑动时间窗口解决了临界时间点上突发流量无法控制的问题，但是却因为要存储每个小的时间窗口内的计数，导致空间复杂度有所增加。虽然滑动时间窗口解决了窗口边界的大流量的问题，但还是无法限制短时间之内的集中流量，也就是说无法让流量更加平滑

### 令牌桶
漏桶算法在面对突发流量的时候，采用的解决方式是缓存在漏桶中，这样流量的响应时间就会增长，这与互联网业务低延迟的要求不符；而令牌桶算法可以在令牌中暂存一定量的令牌，能够应对一定的突发流量，所以一般我会使用令牌桶算法来实现限流方案

使用令牌桶算法就需要存储令牌的数量，如果是单机限流的话，可以在进程中使用一个变量来存储；如果是分布式限流的话，一般使用 Redis 存储令牌的数量。这样的话，每次请求的时候都需要请求一次 Redis 来获取一个令牌，会增加几毫秒的延迟，性能上会有一些损耗。因此，一个折中的思路是：在每次取令牌的时候，不再只获取一个令牌，而是获取一批令牌，这样可以尽量减少请求 Redis 的次数


### 漏桶限


## 限流模式
### 单机限流
针对单个实例的访问频率进行限制

### 分布式限流
针对某个服务的多个实例的总的访问频率进行限制

单机限流只需要在单个实例中维护自己的接口请求计数器。而分布式限流需要集中管理计数器，这样才能做到多个实例对同一个计数器累加计数，以便实现对多个实例总访问频率的限制

分布式限流基于外部存储 Redis，网络通信成本较高。对于 Redis 的各种异常情况，捕获并封装为统一的异常，向上抛出或者吞掉就可以了。比较难处理的是 Redis 访问超时。Redis 访问超时会严重影响接口的响应时间，甚至导致接口请求超时。所以，在访问 Redis 时，需要设置合理的超时时间。一旦超时，我们就判定为限流失效，继续执行接口请求

Redis 访问超时时间的设置既不能太大也不能太小，太大可能会影响到接口的响应时间，太小可能会导致太多的限流失效。可以通过压测或者线上监控，获取到 Redis 访问时间分布情况，再结合接口可以容忍的限流延迟时间，权衡设置一个较合理的 Redis 超时时间


## 集成使用
