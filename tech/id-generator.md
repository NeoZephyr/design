## 作用
单调递增性，提升数据的写入性能，便于排序
在数据库分库分表后，保证 ID 的全局唯一性


## Snowflake
Snowflake 的核心思想是将 64bit 的二进制数字分成若干部分：
1 位兼容位恒为 0
41 位时间信息
10 位存储 IDC 信息及业务信息
10 位自增信息


## 实现方式
### 业务服务器
这种方案的好处是业务代码在使用的时候不需要跨网络调用，性能上会好一些，但是就需要更多的机器 ID 位数来支持更多的业务服务器。另外，由于业务服务器的数量很多，需要引入 ZooKeeper 来保证每次机器重启时都能获得唯一的机器 ID

### 独立服务部署
业务在使用发号器的时候需要多一次的网络调用，但是内网的调用对于性能的损耗有限，却可以减少机器 ID 的位数，如果发号器以主备方式部署，同时运行的只有一个发号器，那么机器 ID 可以省略，这样可以留更多的位数给最后的自增信息位

即使需要机器 ID，因为发号器部署实例数有限，那么就可以把机器 ID 写在发号器的配置文件里，这样即可以保证机器 ID 唯一性，无需引入第三方组件


## 发号器问题
### 依赖系统时间戳
一旦系统时间不准，就有可能生成重复的 ID。如果发现系统时钟不准，就让发号器暂时拒绝发号，直到时钟准确为止

### ID 倾斜
如果请求发号器的 QPS 不高，比如说发号器每毫秒只发一个 ID，就会造成生成 ID 的末位永远是 1，在分库分表时如果使用 ID 作为分区键就会造成库表分配的不均匀。解决办法主要有两个：

1. 时间戳不记录毫秒而是记录秒，这样在一个时间区间里可以多发出几个号，避免出现分库分表时数据分配不均
2. 生成的序列号的起始号可以做一下随机，这一秒是 21，下一秒是 30