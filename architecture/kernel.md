## 基础架构
### 冯·诺依曼计算机体系
由中央处理器 + 存储 + 一系列的输入输出设备构成。其中，提供了编程接口的是中央处理器 CPU，编程接口是 CPU 指令

### 编程语言
降低 CPU 指令的使用门槛

### 操作系统
中断的设计初衷是 CPU 响应硬件设备事件的一个机制。当某个输入输出设备发生了一件需要 CPU 来处理的事情，它就会触发一个中断；但是 CPU 也提供了指令允许软件触发一个中断，叫软中断，也称作系统调用。大部分情况下，操作系统的能力通过软中断向其他软件开放


## 系统调用
根据与应用的关系，可以把操作系统分为内核与外围

### 内核
操作系统内核，就是为应用程序提供系统服务的子系统的集合，它们管理着计算机的所有硬件资源，也管理着所有运行中的应用软件

Intel CPU 通常把代码执行权限分为 Ring 0-3 四个等级，操作系统内核通常运行在 Ring0，而常规的软件进程运行在 Ring3

系统调用所基于的软中断，很像一次间接的函数调用。应用程序运行在 Ring3，即用户态，而操作系统内核运行在 Ring0，即内核态。一次中断调用，除了函数调用，而且还改变了执行权限，从用户态跃迁到了内核态

操作系统与我们编写的软件并不同属一个进程，两边的内存地址空间都是独立的，系统调用请求，传递给操作系统的内存地址，是用户进程的内存地址。

从虚拟内存机制的视角，操作系统内核和所有进程都在同一个地址空间，也就是，操作系统内核是所有进程共享的内存。操作系统内核的代码和数据，不只为所有进程所共享，而且在所有进程中拥有相同的地址。这样无论哪个进程请求过来，对内核来说都是一次本进程内的请求。从单个进程的视角看，中断向量表的地址，以及操作系统内核的地址空间是一个契约。有了中断向量表的地址约定，用户态函数就可以发起一次系统调用

既然操作系统内核和应用程序同属一个地址空间，是否可以跳过中断，直接访问调用内核函数?
1. 执行权限问题
2. 涉及虚拟内存中的内存页保护机制。内存页可以设置可读、可写、可执行三个标记位。操作系统内核虽然和用户进程同属一个地址空间，但是被设置为不可读、不可写、不可执行。虽然这段地址空间是有内容的，但是对于用户来说是个黑洞


## 编程接口
最原始的调用方式，是用软中断指令。大部分高级语言都实现了操作系统编程接口的封装

## 动态库
动态库是实现了一个语言无关的代码复用机制。它是二进制级别的复用，大大降低了编程语言标准库的工作量。有了动态库，编程语言的设计者实现其标准库来说就多了一个选择：直接调用动态库的函数并进行适度的语义包装。大部分语言会选择这条路，而不是直接用系统调用

动态库的原理
1. 动态库本质上是在一个进程地址空间中动态加载程序片段，这个程序片段的地址在编译阶段是没法确定的，需要在加载动态库的过程把浮动地址固定下来。这块的技术非常成熟，之前在实模式下加载进程就已经在使用这样的技术了
2. 动态库需要记录有哪些函数被导出，这样用户就可以通过函数的名字来取得对应的函数地址

