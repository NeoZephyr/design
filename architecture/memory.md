## 内存管理
从操作系统的视角看，从开机到关机，整个计算过程如下：BIOS，引导区引导程序，OS 引导程序，Shell 程序

BIOS 程序没有固化在 CPU 中，而是独立放到主板的 ROM 上，是因为不同历史时期的计算机输入输出设备很不一样，有键盘 + 鼠标 + 显示器的，有触摸屏的，也有纯语音交互的，外置存储则有软盘，硬盘，闪存，我们可以通过调整 BIOS 程序应对，而不需要修改 CPU

引导区引导程序，是程序从内置存储转到外置存储的边界。引导区引导程序很短，BIOS 只需要把它加载到内存执行就可以，这样系统的控制权就转到外置存储了。引导区引导程序不固化在 BIOS 中，而是写在外置存储的引导区，是为了避免 BIOS 程序需要经常性修改。毕竟 BIOS 还是硬件，而引导区引导程序已经属于软件范畴了，修改起来会方便很多

OS 引导程序，所有初始化工作完成后，操作系统会把执行权交给 OS Shell 程序

OS Shell 程序，负责操作系统与用户的交互。Shell 负责解释命令行，然后启动相应的软件。而计算机是如何运行外置存储上的软件，就与内存管理有关

### 实模式
在实模式操作系统下，所有软件包括操作系统本身，都在同一个物理地址空间下，CPU 直接通过物理地址访问内存。有以下两种内存分配方法：
1. 把内存管理相关的函数地址，放到一个公认的地方，每个软件要想申请内存就到这个地方取得内存管理函数并调用它
2. 把内存管理功能设计为一个中断请求。所谓中断，是 CPU 响应硬件设备事件的一个机制。比如：当某个输入输出设备发生了一件需要 CPU 来处理的事情，它就会触发一个中断。中断机制设计之初本来为响应硬件事件之用，但是 CPU 也提供了指令允许软件触发一个中断，叫做软中断

运行外置存储上的软件：
把软件完整从外置存储读入到内存然后执行它。在执行前，把浮动地址固定下来。这是因为软件还没有加载到内存的时候并不知道自己所处的位置，所以有很多涉及数据的地址、函数的地址都没法固定下来，要在操作系统把它加载到内存时来确定

实模式有两个严重问题：
1. 安全性：操作系统以及所有软件都运行在一起，相互之间可以随意修改对方的数据甚至程序指令
2. 软件复杂性低，同时可运行的软件数量少。软件越复杂，需要的存储空间越大，甚至可能出现单个软
件的大小超过计算机的可用内存，这时在实模式下就无法执行。而且，即是单个软件可运行，但是一旦我们同时运行多个软件，操作系统对内存的需求量就会急剧增加，内存的存储空间严重不足

### 保护模式
保护模式下，内存访问不再是直接通过物理内存，而是基于虚拟内存。虚拟内存模式下，整个内存空间被分成很多个连续的内存页。每个内存页大小是固定的，比如 64K。每次 CPU 访问某个虚拟内存地址中的数据，会先计算出要访问的是哪个内存页，然后 CPU 再通过一个地址映射表，把虚拟的内存地址转为物理的内存地址，然后到这个物理内存地址去读取数据。地址映射表是一个数组，下标是内存页页号，值是该内存页对应的物理内存首地址

如果某一个内存页对应的物理内存地址还不存在，即出现缺页情况，没法读取数据，这时 CPU 就会发起一个缺页的中断请求。这个缺页的中断请求会被操作系统接管，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据。如果没有空闲的物理内存可以分配，它就会选择一个最久没有被访问的内存页进行淘汰。当然，淘汰前会把这个内存页的数据保存起来，因为下次 CPU 访问这个被淘汰的内存页时一样会发生缺页中断请求，那时操作系统还要去恢复数据

通过这个虚拟内存的机制，操作系统并不需要一次就把整个软件装进内存中，而是通过缺页中断按需加载对应的程序代码片段。而且，多个软件同时运行导致内存不够用的时候，就把最久没有用过的内存页淘汰掉，腾出物理内存出来

每个运行中的软件叫进程，都有自己的地址映射表。也就是说，虚拟地址并不是全局的，而是每个进程有一个自己独立的虚拟地址空间
